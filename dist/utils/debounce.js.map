{"version":3,"sources":["utils/debounce.js"],"names":[],"mappings":";;;;;;YAagB;;;;;;;;;;;;;;AAAT,aAAS,QAAT,CAAkB,IAAlB,EAAwB,IAAxB,EAA8B,SAA9B,EAAyC;;;;AAC5C,YAAI,mBAAJ,CAD4C;AAE5C,eAAO,YAAM;AACT,gBAAM,eAAN;gBAAsB,iBAAtB,CADS;AAET,gBAAM,QAAQ,SAAR,KAAQ,GAAM;AAChB,0BAAU,IAAV,CADgB;AAEhB,oBAAI,CAAC,SAAD,EAAY,KAAK,KAAL,CAAW,OAAX,EAAoB,IAApB,EAAhB;aAFU,CAFL;AAMT,gBAAM,UAAU,aAAa,CAAC,OAAD,CANpB;AAOT,yBAAa,OAAb,EAPS;AAQT,sBAAU,WAAW,KAAX,EAAkB,IAAlB,CAAV,CARS;AAST,gBAAI,OAAJ,EAAa,KAAK,KAAL,CAAW,OAAX,EAAoB,IAApB,EAAb;SATG,CAFqC;KAAzC","file":"utils/debounce.js","sourcesContent":["/**\n * Debounce\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * http://davidwalsh.name/javascript-debounce-function\n *\n * @param {Function} func     [function to debounce]\n * @param {Number} wait       [time to wait]\n * @param {Boolean} immediate []\n */\nexport function debounce(func, wait, immediate) {\n    let timeout;\n    return () => {\n        const context = this, args = arguments;\n        const later = () => {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n}\n"],"sourceRoot":"/source/"}